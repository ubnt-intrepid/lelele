//! code generation.

use crate::{
    dfa::NodeID,
    grammar::{Grammar, SymbolID},
    parse_table::{ParseTable, ResolvedAction},
};
use std::fmt;

#[derive(Debug)]
pub struct Codegen<'g> {
    grammar: &'g Grammar,
    parse_table: &'g ParseTable,
}

impl<'g> Codegen<'g> {
    pub fn new(grammar: &'g Grammar, parse_table: &'g ParseTable) -> Self {
        Self {
            grammar,
            parse_table,
        }
    }

    fn fmt_preamble(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        const PREAMBLE: &str = "\
// This file is automatically generated by lelele.

use ::lelele_runtime::_private as lelele;

/// The alias to parser type using generated parser definition.
pub type Parser<TTok> = lelele::Parser<ParserDef, TTok>;

/// Create an instance of parser using generated definition.
pub fn parser<TTok>() -> Parser<TTok>
where
    TTok: lelele::Token<SymbolID>,
{
    lelele::Parser::new(
        ParserDef::default()
    )
}

/// The generated LR(1) parse table.
#[derive(Default)]
pub struct ParserDef {
    _p: (),
}

impl lelele::ParserDef for ParserDef {
    type State = NodeID;
    type Symbol = SymbolID;
    type Reduce = RuleID;

    #[inline]
    fn initial_state(&self) -> Self::State {
        NodeID::__START
    }

    #[inline]
    fn action<TCtx>(&self, mut cx: TCtx) -> Result<TCtx::Ok, TCtx::Err>
    where
        TCtx: lelele::ParseContext<
            State = Self::State,
            Symbol = Self::Symbol,
            Reduce = Self::Reduce,
        >,
    {
        match PARSE_TABLE.get(cx.current_state().__raw) {
            Some(actions) => {
                let lookahead = cx.lookahead().unwrap_or(SymbolID::__EOI).__raw;
                match actions.get(&lookahead) {
                    Some(ParseAction::Shift(n)) => cx.shift(*n)?,
                    Some(ParseAction::Reduce(r, s, i)) => cx.reduce(*r, *s, *i)?,
                    Some(ParseAction::Accept) => cx.accept()?,
                    None => cx.error(\"incorrect symbol\")?,
                }
            },
            None => cx.error(\"incorrect state\")?,
        }
        cx.end()
    }
}
";
        f.write_str(PREAMBLE)
    }

    fn fmt_node_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify DFA state nodes.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct NodeID { __raw: usize }
impl NodeID {\n",
        )?;

        writeln!(
            f,
            "    const __START: Self = Self {{ __raw: {} }};",
            NodeID::START
        )?;

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_symbol_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify terminal or nonterminal symbols used in generated DFA.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct SymbolID { __raw: u64 }
impl SymbolID {\n",
        )?;

        writeln!(
            f,
            "const __EOI: Self = Self {{ __raw: {} }};",
            SymbolID::EOI.raw(),
        )?;

        for (id, symbol) in self.grammar.symbols() {
            let export_name = match symbol.export_name() {
                Some(name) => name,
                None => continue,
            };
            writeln!(
                f,
                "\
/// `{export_name}`
pub const {export_name}: Self = Self {{ __raw: {id} }};",
                export_name = export_name,
                id = id.raw(),
            )?;
        }

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_rule_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify the syntax rule that matched input sequence.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct RuleID { __raw: u64 }
impl RuleID {\n",
        )?;

        'rules: for (rule_id, rule) in self.grammar.rules() {
            let export_name = match rule.export_name() {
                Some(name) => name,
                None => continue 'rules,
            };

            let comment_lhs = match self.grammar.symbol(rule.left()).export_name() {
                Some(name) => name,
                None => continue 'rules,
            };

            let mut comment_rhs = String::new();
            for (i, s) in rule.right().iter().enumerate() {
                let name = match self.grammar.symbol(*s).export_name() {
                    Some(name) => name,
                    None => continue 'rules,
                };
                if i > 0 {
                    comment_rhs += " ";
                }
                comment_rhs += name;
            }

            writeln!(f, "    /// `{} : {}`", comment_lhs, comment_rhs)?;
            writeln!(
                f,
                "    pub const {export_name}: Self = Self {{ __raw: {id} }};",
                export_name = export_name,
                id = rule_id.raw()
            )?;
        }

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_parse_table(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
enum ParseAction {
    Shift(NodeID),
    Reduce(RuleID, SymbolID, usize),
    Accept,
}
const PARSE_TABLE: &[ lelele::phf::Map<u64, ParseAction> ] = &[\n",
        )?;

        for (_, actions) in &self.parse_table.map {
            let mut actions_g = phf_codegen::Map::<u64>::new();
            actions_g.phf_path("lelele::phf");

            for (symbol, action) in actions.iter() {
                let action_g = match action {
                    ResolvedAction::Shift(n) => {
                        format!("ParseAction::Shift(NodeID {{ __raw: {} }})", n)
                    }
                    ResolvedAction::Reduce(r) => {
                        let rule = self.grammar.rule(*r);
                        format!("ParseAction::Reduce(RuleID {{ __raw: {} }}, SymbolID {{ __raw: {} }}, {})", r.raw(), rule.left().raw(), rule.right().len())
                    }
                    ResolvedAction::Accept => "ParseAction::Accept".into(),
                    ResolvedAction::Fail => continue,
                };
                actions_g.entry(symbol.raw(), &action_g);
            }

            writeln!(f, "{},", actions_g.build())?;
        }

        f.write_str("];\n")?;

        Ok(())
    }
}

impl<'g> fmt::Display for Codegen<'g> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.fmt_preamble(f)?;
        self.fmt_node_id_def(f)?;
        self.fmt_symbol_id_def(f)?;
        self.fmt_rule_id_def(f)?;
        self.fmt_parse_table(f)?;
        Ok(())
    }
}
