//! code generation.

use crate::{
    dfa::{Action, NodeID, DFA},
    grammar::{Grammar, RuleID, SymbolID},
};
use indexmap::{IndexMap, IndexSet};
use std::fmt;

#[derive(Debug)]
pub struct ParserDefinition<'g> {
    grammar: &'g Grammar<'g>,
    table: IndexMap<NodeID, IndexMap<SymbolID, Action>>,
    start_node: NodeID,
    node_ids: IndexSet<NodeID>,
    symbol_ids: IndexSet<SymbolID>,
    rule_ids: IndexSet<RuleID>,
}

impl<'g> ParserDefinition<'g> {
    pub fn new(grammar: &'g Grammar<'g>) -> Self {
        let dfa = DFA::generate(&grammar);
        let start_node = dfa.start_node().0;
        let table = dfa.parse_table();

        // 使用されている NodeID, RuleID, SymbolID を集計し、コード生成用に並び換える
        let node_ids: IndexSet<NodeID> = table.keys().copied().collect();
        let mut symbol_ids: IndexSet<SymbolID> = IndexSet::new();
        let mut rule_ids: IndexSet<RuleID> = IndexSet::new();

        // reserved IDs
        symbol_ids.insert(SymbolID::EOI);
        symbol_ids.insert(SymbolID::START);
        rule_ids.insert(RuleID::START);

        for (symbol, action) in table.values().flatten() {
            symbol_ids.insert(*symbol);
            if let Action::Reduce(r) = action {
                let rule = grammar.rule(*r);
                symbol_ids.insert(rule.lhs);
                symbol_ids.extend(rule.rhs.iter().copied());
                rule_ids.insert(*r);
            }
        }

        Self {
            grammar,
            start_node,
            table,
            node_ids,
            symbol_ids,
            rule_ids,
        }
    }

    fn node_id_of(&self, n: &NodeID) -> usize {
        self.node_ids.get_index_of(n).unwrap()
    }

    fn symbol_id_of(&self, s: &SymbolID) -> usize {
        self.symbol_ids.get_index_of(s).unwrap()
    }

    fn rule_id_of(&self, r: &RuleID) -> usize {
        self.rule_ids.get_index_of(r).unwrap()
    }

    fn fmt_preamble(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        const PREAMBLE: &str = "\
// This file is automatically generated by lelele.

use ::lelele_runtime::_private as lelele;

/// The alias to parser type using generated parser definition.
pub type Parser<TTok> = lelele::Parser<ParserDefinition, TTok>;

/// Create an instance of parser using generated definition.
pub fn parser<TTok>() -> Parser<TTok>
where
    TTok: lelele::Token<SymbolID>,
{
    lelele::Parser::new(
        ParserDefinition::default()
    )
}

/// The parser definition.
#[derive(Default)]
pub struct ParserDefinition {
    _p: (),
}

impl lelele::ParserDefinition for ParserDefinition {
    type State = NodeID;
    type Symbol = SymbolID;
    type Reduce = RuleID;

    #[inline]
    fn initial_state(&self) -> Self::State {
        NodeID::__START
    }

    #[inline]
    fn action(
        &self,
        current: Self::State,
        input: Option<Self::Symbol>,
    ) -> Result<lelele::ParserAction<Self::State, Self::Symbol, Self::Reduce>, lelele::ParserActionError> {
        let input = input.unwrap_or(SymbolID::__EOI).__raw;
        let actions = PARSE_TABLE.get(current.__raw).ok_or_else(|| lelele::ParserActionError::IncorrectState)?;
        actions.get(&input).copied().ok_or_else(|| lelele::ParserActionError::IncorrectSymbol)
    }
}
";
        f.write_str(PREAMBLE)
    }

    fn fmt_node_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify DFA state nodes.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct NodeID { __raw: usize }
impl NodeID {\n",
        )?;

        writeln!(
            f,
            "    const __START: Self = Self {{ __raw: {}_usize }};",
            self.node_id_of(&self.start_node)
        )?;

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_symbol_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify terminal or nonterminal symbols used in generated DFA.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct SymbolID { __raw: u64 }
impl SymbolID {\n",
        )?;

        for (id, symbol) in self
            .grammar
            .symbols()
            .filter(|(id, _)| *id != SymbolID::EOI && *id != SymbolID::START)
        {
            writeln!(
                f,
                "    \
    /// `\"{name}\"`
    pub const {name}: Self = Self {{ __raw: {id}_u64 }};",
                name = symbol.name(),
                id = self.symbol_id_of(&id)
            )?;
        }

        writeln!(
            f,
            "    const __EOI: Self = Self {{ __raw: {}_u64 }};",
            self.symbol_id_of(&SymbolID::EOI)
        )?;

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_rule_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify the syntax rule that matched input sequence.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct RuleID { __raw: u64 }
impl RuleID {\n",
        )?;

        for (id, rule) in self.grammar.rules().filter(|(id, _)| *id != RuleID::START) {
            writeln!(
                f,
                "    \
    /// `\"{name}\"`
    pub const {name}: Self = Self {{ __raw: {id}_u64 }};",
                name = rule.name,
                id = self.rule_id_of(&id)
            )?;
        }

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_parse_table(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
const PARSE_TABLE: &[
    lelele::phf::Map<
        u64,
        lelele::ParserAction<
            NodeID,
            SymbolID,
            RuleID,
        >,
    >
] = &[\n",
        )?;

        for actions in self.table.values() {
            let mut actions_g = phf_codegen::Map::<u64>::new();
            actions_g.phf_path("lelele::phf");
            for (symbol, action) in actions {
                let action_g = match action {
                    Action::Shift(n) | Action::Goto(n) => {
                        format!(
                            "lelele::ParserAction::Shift(NodeID {{ __raw: {}_usize }})",
                            self.node_id_of(n)
                        )
                    }
                    Action::Reduce(r) => {
                        let rule = self.grammar.rule(*r);
                        format!(
                        "lelele::ParserAction::Reduce(RuleID {{ __raw: {}_u64 }}, SymbolID {{ __raw: {}_u64 }}, {}_usize)",
                        self.rule_id_of(r),
                        self.symbol_id_of(&rule.lhs),
                        rule.rhs.len()
                    )
                    }
                    Action::Accept => format!("lelele::ParserAction::Accept"),
                };
                actions_g.entry(self.symbol_id_of(&symbol) as u64, &action_g);
            }
            writeln!(f, "{},", actions_g.build())?;
        }

        f.write_str("];\n")?;

        Ok(())
    }
}

impl<'g> fmt::Display for ParserDefinition<'g> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.fmt_preamble(f)?;
        self.fmt_node_id_def(f)?;
        self.fmt_symbol_id_def(f)?;
        self.fmt_rule_id_def(f)?;
        self.fmt_parse_table(f)?;
        Ok(())
    }
}
