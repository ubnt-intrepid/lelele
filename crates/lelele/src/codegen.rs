//! code generation.

use crate::{
    dfa::{Action, NodeID, DFA},
    grammar::{Grammar, RuleID},
};
use std::fmt;

#[derive(Debug)]
pub struct Codegen<'g> {
    grammar: &'g Grammar,
    dfa: &'g DFA,
}

impl<'g> Codegen<'g> {
    pub fn new(grammar: &'g Grammar, dfa: &'g DFA) -> Self {
        Self { grammar, dfa }
    }

    fn fmt_preamble(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
// This file is automatically generated by lelele.
use ::lelele_runtime::_private as lelele;
",
        )
    }

    fn fmt_node_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify DFA state nodes.
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(transparent)]
pub struct NodeID { __raw: usize }
impl NodeID {\n",
        )?;

        writeln!(
            f,
            "    const __START: Self = Self {{ __raw: {} }};",
            NodeID::START
        )?;

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_token_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify terminal or nonterminal symbols used in generated DFA.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[allow(non_camel_case_types)]
pub enum TokenID {\n",
        )?;

        for terminal in self.grammar.terminals() {
            let export_name = match terminal.export_name() {
                Some(name) => name,
                None => continue,
            };
            writeln!(
                f,
                "#[doc = \"Terminal `{export_name}`\"] {export_name},",
                export_name = export_name,
            )?;
        }

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_symbol_id_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The type to identify nonterminal symbols used in generated DFA.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Symbol {\n",
        )?;

        for symbol in self.grammar.nonterminals() {
            let export_name = match symbol.export_name() {
                Some(name) => name,
                None => continue,
            };
            writeln!(
                f,
                "\
/// Nonterminal `{export_name}`
{export_name},",
                export_name = export_name,
            )?;
        }

        f.write_str("}\n")?;

        Ok(())
    }

    fn fmt_parser_def(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(
            "\
/// The generated LR(1) parse table.
#[derive(Debug, Default)]
pub struct ParserDef {
    _p: (),
}
impl lelele::ParserDef for ParserDef {
    type State = NodeID;
    type Token = TokenID;
    type Symbol = Symbol;
    #[inline]
    fn initial_state(&self) -> Self::State {
        NodeID::__START
    }
    #[inline]
    fn action<TAction>(
        &self,
        current: Self::State,
        lookahead: Option<Self::Token>,
        action: TAction,
    ) -> Result<TAction::Ok, TAction::Error>
    where
        TAction: lelele::ParseAction<
            State = Self::State,
            Token = Self::Token,
            Symbol = Self::Symbol,
        >,
    {
        __action(current, lookahead, action)
    }
    #[inline]
    fn goto(&self, current: Self::State, symbol: Self::Symbol) -> Self::State {
        __goto(current, symbol)
    }
}\n",
        )?;

        f.write_str(
            "\
#[inline]
fn __action<TAction>(
    current: NodeID,
    lookahead: Option<TokenID>,
    action: TAction,
) -> ::std::result::Result<TAction::Ok, TAction::Error>
where
    TAction: lelele::ParseAction<
        State = NodeID,
        Token = TokenID,
        Symbol = Symbol,
    >,
{
    match current.__raw {\n",
        )?;

        for (id, node) in self.dfa.nodes() {
            writeln!(f, "{} => match lookahead {{", id)?;
            for (lookahead, action) in node.actions() {
                let variant = match self.grammar.terminal(&lookahead).export_name() {
                    Some(name) => format!("Some(TokenID::{})", name),
                    None => "None".into(),
                };
                let action_g = match action {
                    Action::Shift(n) => {
                        format!("action.shift(NodeID {{ __raw: {} }}),", n)
                    }
                    Action::Reduce(rule) if *rule == RuleID::ACCEPT => {
                        format!("action.accept(),")
                    }
                    Action::Reduce(rule) => {
                        let rule = self.grammar.rule(rule);
                        let left = self
                            .grammar
                            .nonterminal(&rule.left())
                            .export_name()
                            .unwrap();
                        format!(
                            "action.reduce(Symbol::{left}, {n}),",
                            left = left,
                            n = rule.right().len(),
                        )
                    }
                    _ => continue,
                };
                writeln!(f, "  {} => {}", variant, action_g)?;
            }

            writeln!(f, "  #[allow(unreachable_patterns)] _ => action.fail([")?;
            for name in node
                .actions()
                .filter_map(|(t, _)| self.grammar.terminal(&t).export_name())
            {
                writeln!(f, "    TokenID::{},", name)?;
            }
            write!(f, "  ]),\n}},\n")?;
        }

        f.write_str(
            "\
#[allow(unreachable_patterns)]
_ => unreachable!(),
}
}\n",
        )?;

        f.write_str(
            "\
#[inline]
fn __goto(current: NodeID, symbol: Symbol) -> NodeID {
    match current.__raw {\n",
        )?;

        for (id, node) in self.dfa.nodes() {
            if node.gotos().count() == 0 {
                continue;
            }
            writeln!(f, "{} => match symbol {{", id)?;
            for (symbol, target) in node.gotos() {
                let symbol = self.grammar.nonterminal(&symbol).export_name().unwrap();
                writeln!(f, "  Symbol::{} => NodeID {{ __raw: {} }},", symbol, target)?;
            }
            writeln!(f, "  #[allow(unreachable_patterns)] _ => unreachable!(),")?;
            writeln!(f, "}},")?;
        }

        f.write_str("#[allow(unreachable_patterns)] _ => unreachable!(),\n}\n}\n")?;

        Ok(())
    }
}

impl<'g> fmt::Display for Codegen<'g> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.fmt_preamble(f)?;
        self.fmt_node_id_def(f)?;
        self.fmt_token_id_def(f)?;
        self.fmt_symbol_id_def(f)?;
        self.fmt_parser_def(f)?;
        Ok(())
    }
}
