// ref: https://github.com/gfngfn/SATySFi/blob/v0.0.9/src/frontend/parser.mly

@prec { assoc = left } prec_binop_bar;
@prec { assoc = left } prec_binop_amp;
@prec { assoc = right } prec_binop_cmp;
@prec { assoc = right } prec_binop_hat;
@prec { assoc = right } prec_binop_add;
@prec { assoc = left } prec_binop_sub;
@prec { assoc = right } prec_binop_mul;

@terminal VAR;
@terminal HORZ_CMD;
@terminal VERT_CMD;
@terminal HORZ_MACRO;
@terminal VERT_MACRO;
@terminal MATH_CMD;
@terminal VAR_WITH_MOD;
@terminal HORZ_CMD_WITH_MOD;
@terminal VERT_CMD_WITH_MOD;
@terminal MATH_CMD_WITH_MOD;
@terminal VAR_IN_HORZ;
@terminal VAR_IN_VERT;
@terminal VAR_IN_MATH;
@terminal TYPE_VAR;
@terminal CONSTRUCTOR;
@terminal INT_CONST;
@terminal FLOAT_CONST;
@terminal LENGTH_CONST;
@terminal CHAR;
@terminal LITERAL;
@terminal POSITIONED_LITERAL;
@terminal SPACE BREAK;
@terminal MATCHARS;
@terminal PRIMES;
@terminal SUBSCRIPT SUPERSCRIPT;
@terminal LAMBDA ARROW COMMAND;
@terminal LET_REC LET_NONREC DEF_EQ LET_AND IN OPEN;
@terminal OPEN_MODULE;
@terminal MODULE STRUCT END DIRECT SIG VAL CONSTRAINT;
@terminal TYPE OF MATCH WITH BAR WILDCARD WHEN AS COLON;
@terminal LET_MUTABLE OVERWRITE_EQ;
@terminal LET_HORZ LET_VERT LET_MATH;
@terminal IF THEN ELSE;
@terminal UNOP_EXCLAM;
@terminal BEFORE LNOT EXACT_AMP EXACT_TILDE;
@terminal LPAREN RPAREN;
@terminal BVERTGRP EVERTGRP;
@terminal BHORZGRP EHORZGRP;
@terminal BMATHGRP EMATHGRP;
@terminal BPATH EPATH PATHLINE PATHCURVE CONTROLS CYCLE;
@terminal TRUE FALSE;
@terminal SEP ENDACTIVE COMMA;
@terminal BLIST LISTPUNCT ELIST BRECORD ERECORD ACCESS;
@terminal WHILE DO;
@terminal HORZCMDTYPE VERTCMDTYPE MATHCMDTYPE;
@terminal OPTIONAL OMISSION OPTIONALTYPE OPTIONALARROW;
// @terminal NEWGLOBALHASH OVERWRITEGLOBALHASH RENEWGLOBALHASH;
@terminal ITEM;
@terminal HEADER_REQUIRE HEADER_IMPORT;
@terminal HEADER_STAGE0 HEADER_STAGE1 HEADER_PERSISTENT0;
@terminal EOF;

@terminal { prec = prec_binop_bar } BINOP_BAR;
@terminal { prec = prec_binop_amp } BINOP_AMP;
@terminal { prec = prec_binop_cmp } BINOP_EQ BINOP_GT BINOP_LT;
@terminal { prec = prec_binop_hat } BINOP_HAT CONS;
@terminal { prec = prec_binop_add } BINOP_PLUS;
@terminal { prec = prec_binop_sub } BINOP_MINUS EXACT_MINUS;
@terminal { prec = prec_binop_mul } BINOP_TIMES EXACT_TIMES BINOP_DIVIDES MOD;

@start Main;

//-----------------------------------------------------------------------

@nonterminal Main;
@rule Main :=
    | Stage HeaderElemList NxToplevel
    | Stage HeaderElemList NxWhl EOF
    | EOF
    ;

@nonterminal Stage;
@rule Stage :=
    | @empty
    | HEADER_STAGE0
    | HEADER_STAGE1
    | HEADER_PERSISTENT0
    ;

@nonterminal HeaderElem;
@rule HeaderElem :=
    | HEADER_REQUIRE
    | HEADER_IMPORT
    ;

@nonterminal HeaderElemList;
@rule HeaderElemList :=
    | @empty
    | HeaderElem HeaderElemList
    ;

@nonterminal NxToplevel;
@rule NxToplevel :=
    | LET_REC NxRecDec NxTopSubSeq
    | LET_NONREC NxNonRecDec NxTopSubSeq
    | LET_MUTABLE VAR OVERWRITE_EQ NxLet NxTopSubSeq
    | LET_HORZ NxHorzDec NxTopSubSeq
    | LET_VERT NxVertDec NxTopSubSeq
    | LET_MATH NxMathDec NxTopSubSeq
    | TYPE NxVariantDec NxTopSubSeq
    | MODULE CONSTRUCTOR NxSigOpt DEF_EQ STRUCT NxStruct NxTopSubSeq
    | OPEN CONSTRUCTOR NxTopSubSeq
    | LET_HORZ NxHorzMacroDec NxTopSubSeq
    | LET_VERT NxVertMacroDec NxTopSubSeq
    ;

@nonterminal NxTopSubSeq;
@rule NxTopSubSeq :=
    | NxToplevel
    | EOF
    | IN NxLet EOF
    ;

@nonterminal NxSigOpt;
@rule NxSigOpt :=
    | @empty
    | COLON SIG NxSigElemList END
    ;

@nonterminal NxSigElemList;
@rule NxSigElemList :=
    | @empty
    | NxSigElem NxSigElemList
    ;

@nonterminal NxSigElem;
@rule NxSigElem :=
    | TYPE TypeVarList VAR Constraints
    | VAL VAR COLON TxFunc Constraints
    | VAL LPAREN BinOp RPAREN COLON TxFunc Constraints
    | VAL HORZ_CMD COLON TxFunc Constraints
    | VAL VERT_CMD COLON TxFunc Constraints
    | DIRECT HORZ_CMD COLON TxFunc Constraints
    | DIRECT VERT_CMD COLON TxFunc Constraints
    ;

@nonterminal Constraints;
@rule Constraints :=
    | ConstraintList
    ;

@nonterminal ConstraintList;
@rule ConstraintList :=
    | @empty
    | Constraint ConstraintList
    ;

@nonterminal Constraint;
@rule Constraint :=
    | CONSTRAINT TYPE_VAR CONS KxTop
    ;

@nonterminal NxStruct;
@rule NxStruct :=
    | END
    | LET_REC NxRecDec NxStruct
    | LET_NONREC NxNonRecDec NxStruct
    | LET_MUTABLE VAR OVERWRITE_EQ NxLet NxStruct
    | LET_HORZ NxHorzDec NxStruct
    | LET_VERT NxVertDec NxStruct
    | LET_MATH NxMathDec NxStruct
    | TYPE NxVariantDec NxStruct
    | MODULE CONSTRUCTOR NxSigOpt DEF_EQ STRUCT NxStruct NxStruct
    | OPEN CONSTRUCTOR NxStruct
    ;

@nonterminal NxHorzDec;
@rule NxHorzDec :=
    | VAR HORZ_CMD ArgList DEF_EQ NxLet
    | HORZ_CMD ArgPats DEF_EQ NxLet
    ;

@nonterminal NxVertDec;
@rule NxVertDec :=
    | VAR VERT_CMD ArgList DEF_EQ NxLet
    | VERT_CMD ArgPats DEF_EQ NxLet
    ;

@nonterminal NxMathDec;
@rule NxMathDec :=
    | HORZ_CMD ArgList DEF_EQ NxLet
    ;

@nonterminal MacroParamList;
@rule MacroParamList :=
    | @empty
    | MacroParam MacroParamList
    ;

@nonterminal NxHorzMacroDec;
@rule NxHorzMacroDec :=
    | HORZ_MACRO MacroParamList DEF_EQ NxLet
    ;

@nonterminal NxVertMacroDec;
@rule NxVertMacroDec :=
    | VERT_MACRO MacroParamList DEF_EQ NxLet
    ;

@nonterminal MacroParam;
@rule MacroParam :=
    | VAR
    | EXACT_TILDE VAR
    ;

@nonterminal NonRecDecArgPart;
@rule NonRecDecArgPart :=
    | COLON TxFunc
    | COLON TxFunc BAR ArgListNonempty
    | BAR ArgListNonempty
    | ArgList
    ;

@nonterminal RecDecArgPart;
@rule RecDecArgPart :=
    | COLON TxFunc
    | COLON TxFunc BAR PatBotListNonempty
    | BAR PatBotListNonempty
    | ArgPats
    ;

@nonterminal Arg;
@rule Arg :=
    | PatBot
    | OPTIONAL VAR
    | OPTIONAL LPAREN BinOp RPAREN
    ;

@nonterminal ArgList;
@rule ArgList :=
    | @empty
    | Arg ArgList
    ;

@nonterminal ArgListNonempty;
@rule ArgListNonempty :=
    | Arg
    | Arg ArgList
    ;

@nonterminal PatBotList;
@rule PatBotList :=
    | @empty
    | PatBot PatBotList
    ;

@nonterminal PatBotListNonempty;
@rule PatBotListNonempty :=
    | PatBot
    | PatBot PatBotListNonempty
    ;

@nonterminal NxRecDec;
@rule NxRecDec :=
    | VAR                 RecDecArgPart DEF_EQ NxLet NxRecDecSub
    | LPAREN BinOp RPAREN RecDecArgPart DEF_EQ NxLet NxRecDecSub
    | VAR                 RecDecArgPart DEF_EQ NxLet BAR NxRecDecPar NxRecDecSub
    | LPAREN BinOp RPAREN RecDecArgPart DEF_EQ NxLet BAR NxRecDecPar NxRecDecSub
    ;

@nonterminal NxRecDecPar;
@rule NxRecDecPar :=
    | ArgPats DEF_EQ NxLet BAR NxRecDecPar
    | ArgPats DEF_EQ NxLet
    ;

@nonterminal NxRecDecSub;
@rule NxRecDecSub :=
    | LET_AND NxRecDec
    | @empty
    ;

@nonterminal NxNonRecDec;
@rule NxNonRecDec :=
    | PatBot NonRecDecArgPart DEF_EQ NxLet
    ;

@nonterminal NxVariantDec;
@rule NxVariantDec :=
    | NxTypeEq
    | NxTypeEq LET_AND NxVariantDec
    ;

@nonterminal NxTypeEq;
@rule NxTypeEq :=
    | TypeVarList VAR DEF_EQ BAR Variants Constraints
    | TypeVarList VAR DEF_EQ     Variants Constraints
    | TypeVarList VAR DEF_EQ TxFunc       Constraints
    ;

@nonterminal TypeVarList;
@rule TypeVarList :=
    | @empty
    | TYPE_VAR TypeVarList
    ;

@nonterminal KxTop;
@rule KxTop :=
    | BRECORD TxRecord ERECORD
    ;

@nonterminal NxLet;
@rule NxLet :=
    | MATCH NxLet WITH BAR Pats
    | MATCH NxLet WITH     Pats
    | NxLetSub
    ;

@nonterminal NxLetSub;
@rule NxLetSub :=
    | LET_REC NxRecDec IN NxLet
    | LET_NONREC NxNonRecDec IN NxLet
    | LET_MUTABLE VAR OVERWRITE_EQ NxLet IN NxLet
    | LET_MATH NxMathDec IN NxLet
    | OPEN CONSTRUCTOR IN NxLet
    | NxWhl
    ;

@nonterminal NxWhl;
@rule NxWhl :=
    | WHILE NxLet NxWhl
    | NxIf
    ;

@nonterminal NxIf;
@rule NxIf :=
    | IF NxLet THEN NxLet ELSE NxLet
    | NxBfr
    ;

@nonterminal NxBfr;
@rule NxBfr :=
    | NxLambda BEFORE NxBfr
    | NxLambda
    ;

@nonterminal NxLambda;
@rule NxLambda :=
    | VAR OVERWRITE_EQ NxOp
    | LAMBDA ArgPats ARROW NxOp
    | NxOp
    ;

@nonterminal ArgPats;
@rule ArgPats :=
    | PatBotList
    ;

@nonterminal NxOp;
@rule NxOp :=
    | NxOp BINOP_BAR NxOp
    | NxOp BINOP_AMP NxOp
    | NxOp BINOP_EQ NxOp
    | NxOp BINOP_GT NxOp
    | NxOp BINOP_LT NxOp
    | NxOp BINOP_HAT NxOp
    | NxOp BINOP_PLUS NxOp
    | NxOp BINOP_MINUS NxOp
    | NxOp BINOP_TIMES NxOp
    | NxOp BINOP_DIVIDES NxOp
    | NxOp CONS NxOp
    | NxOp EXACT_MINUS NxOp
    | NxOp EXACT_TIMES NxOp
    | NxOp MOD NxOp
    | EXACT_MINUS NxApp
    | LNOT NxApp
    | CONSTRUCTOR NxBot
    | CONSTRUCTOR
    | NxApp
    ;

@nonterminal NxApp;
@rule NxApp :=
    | NxApp NxUnsub
    | NxApp CONSTRUCTOR
    | COMMAND HCmd
    | NxApp OPTIONAL NxUnsub
    | NxApp OMISSION
    | NxUnsub
    ;

@nonterminal NxUnsub;
@rule NxUnsub :=
    | UNOP_EXCLAM NxBot
    | EXACT_AMP NxBot
    | EXACT_TILDE NxBot
    | NxBot
    ;

@nonterminal NxBot;
@rule NxBot :=
    | NxBot ACCESS VAR
    | VAR
    | VAR_WITH_MOD
    | INT_CONST
    | FLOAT_CONST
    | LENGTH_CONST
    | TRUE
    | FALSE
    | LPAREN RPAREN
    | LPAREN NxLet RPAREN
    | LPAREN NxLet COMMA Tuple RPAREN
    | BHORZGRP SxSep EHORZGRP
    | BVERTGRP VxBlock EVERTGRP
    | LITERAL
    | POSITIONED_LITERAL
    | NxListSynt
    | LPAREN BinOp RPAREN
    | NxRecordSynt
    | BPATH Path EPATH
    | BMATHGRP MathBlock EMATHGRP
    | OPEN_MODULE NxLet RPAREN
    ;

@nonterminal NxListSynt;
@rule NxListSynt :=
    | BLIST ELIST
    | BLIST NxList ELIST
    ;

@nonterminal NxRecordSynt;
@rule NxRecordSynt :=
    | BRECORD ERECORD
    | BRECORD NxRecord ERECORD
    | BRECORD NxBot WITH NxRecord ERECORD
    ;

@nonterminal Path;
@rule Path :=
    | NxBot PathSub
    ;

@nonterminal PathSub;
@rule PathSub :=
    | PathComp PathSub
    | @empty
    | PathCompCycle
    ;

@nonterminal PathComp;
@rule PathComp :=
    | PATHLINE NxBot
    | PATHCURVE CONTROLS NxBot LET_AND NxBot PATHCURVE NxBot
    ;

@nonterminal PathCompCycle;
@rule PathCompCycle :=
    | PATHLINE CYCLE
    | PATHCURVE CONTROLS NxBot LET_AND NxBot PATHCURVE CYCLE
    ;

@nonterminal NxRecord;
@rule NxRecord :=
    | NxRecordField
    | NxRecordField LISTPUNCT
    | NxRecordField LISTPUNCT NxRecord
    ;

@nonterminal NxRecordField;
@rule NxRecordField :=
    | VAR DEF_EQ NxLet
    ;

@nonterminal NxList;
@rule NxList :=
    | NxLet
    | NxLet LISTPUNCT
    | NxLet LISTPUNCT NxList
    ;

@nonterminal Variants;
@rule Variants :=
    | Variant
    | Variant BAR Variants
    ;

@nonterminal Variant;
@rule Variant :=
    | CONSTRUCTOR OF TxFunc
    | CONSTRUCTOR
    ;

@nonterminal TxFunc;
@rule TxFunc :=
    | TxFuncOpts ARROW TxFunc
    | TxProd
    ;

@nonterminal TxFuncOpts;
@rule TxFuncOpts :=
    | TxProd OPTIONALARROW TxFuncOpts
    | TxProd
    ;

@nonterminal TxProd;
@rule TxProd :=
    | TxAppreNonemptyList
    ;

@nonterminal TxAppreNonemptyList;
@rule TxAppreNonemptyList :=
    | TxAppre
    | TxAppre EXACT_TIMES TxAppreNonemptyList
    ;

@nonterminal TxAppre;
@rule TxAppre :=
    | TxApp
    | BLIST TxList ELIST HORZCMDTYPE
    | BLIST TxList ELIST VERTCMDTYPE
    | BLIST TxList ELIST MATHCMDTYPE
    | LPAREN TxFunc RPAREN
    | BRECORD TxRecord ERECORD
    | TYPE_VAR
    ;

@nonterminal TxApp;
@rule TxApp :=
    | TxBot TxApp
    | LPAREN TxFunc RPAREN TxApp
    | TYPE_VAR TxApp
    | TxBot
    ;

@nonterminal TxBot;
@rule TxBot :=
    | VAR
    | VAR_WITH_MOD
    ;

@nonterminal TxList;
@rule TxList :=
    | @empty
    | TxListElem
    | TxListElem LISTPUNCT TxList
    ;

@nonterminal TxListElem;
@rule TxListElem :=
    | TxFunc
    | TxAppre OPTIONALTYPE
    ;

@nonterminal TxRecord;
@rule TxRecord :=
    | TxRecordElem
    | TxRecordElem LISTPUNCT
    | TxRecordElem LISTPUNCT TxRecord
    ;

@nonterminal TxRecordElem;
@rule TxRecordElem :=
    | VAR COLON TxFunc
    ;

@nonterminal Tuple;
@rule Tuple :=
    | NxLet
    | NxLet COMMA Tuple
    ;

@nonterminal Pats;
@rule Pats :=
    | Pat
    | Pat BAR Pats
    ;

@nonterminal Pat;
@rule Pat :=
    | PatAs ARROW NxLetSub
    | PatAs WHEN NxLetSub ARROW NxLetSub
    ;

@nonterminal PatAs;
@rule PatAs :=
    | PatTr AS VAR
    | PatTr
    ;

@nonterminal PatTr;
@rule PatTr :=
    | PatBot CONS PatTr
    | CONSTRUCTOR PatBot
    | CONSTRUCTOR
    | PatBot
    ;

@nonterminal PatBot;
@rule PatBot :=
    | INT_CONST
    | TRUE
    | FALSE
    | LPAREN RPAREN
    | WILDCARD
    | VAR
    | LPAREN BinOp RPAREN
    | LITERAL
    | BLIST ELIST
    | BLIST PatList ELIST
    | LPAREN PatAs RPAREN
    | LPAREN PatAs COMMA PatTuple RPAREN
    ;

@nonterminal PatTuple;
@rule PatTuple :=
    | PatAs
    | PatAs COMMA PatTuple
    ;

@nonterminal PatList;
@rule PatList :=
    | PatAs
    | PatAs LISTPUNCT
    | PatAs LISTPUNCT PatList
    ;

@nonterminal BinOp;
@rule BinOp :=
    | UNOP_EXCLAM
    | BINOP_TIMES
    | BINOP_DIVIDES
    | BINOP_HAT
    | BINOP_EQ
    | BINOP_GT
    | BINOP_LT
    | BINOP_AMP
    | BINOP_BAR
    | BINOP_PLUS
    | BINOP_MINUS
    | EXACT_TIMES
    | EXACT_MINUS
    | MOD
    | BEFORE
    | LNOT
    ;

@nonterminal SxSep;
@rule SxSep :=
    | SEP SxList
    | SxBlock
    | SxItems
    ;

@nonterminal SxItems;
@rule SxItems :=
    | SxItem
    | SxItem SxItems
    ;

@nonterminal SxList;
@rule SxList :=
    | @empty
    |  SxBlock SEP SxList
    ;

@nonterminal SxItem;
@rule SxItem :=
    | ITEM SxBlock
    ;

@nonterminal HCmd;
@rule HCmd :=
    | HORZ_CMD
    | HORZ_CMD_WITH_MOD
    ;

@nonterminal MCmd;
@rule MCmd :=
    | MATH_CMD
    | MATH_CMD_WITH_MOD
    ;

@nonterminal MathBlock;
@rule MathBlock :=
    | SEP MathList
    | MathMain
    ;

@nonterminal MathList;
@rule MathList :=
    | @empty
    | MathMainTerminated MathList
    ;

@nonterminal MathMainTerminated;
@rule MathMainTerminated :=
    | MathMain SEP
    ;

@nonterminal MathMain;
@rule MathMain :=
    | @empty
    | MathTop MathMain
    ;

@nonterminal MathTop;
@rule MathTop :=
    | MathBot
    | MathBot SUPERSCRIPT MathGroup
    | MathBot SUBSCRIPT MathGroup
    | MathBot SUBSCRIPT MathGroup SUPERSCRIPT MathGroup
    | MathBot SUPERSCRIPT MathGroup SUBSCRIPT MathGroup
    | MathBot PRIMES
    | MathBot PRIMES SUPERSCRIPT MathGroup
    | MathBot PRIMES SUBSCRIPT MathGroup
    | MathBot PRIMES SUBSCRIPT MathGroup SUPERSCRIPT MathGroup
    | MathBot PRIMES SUPERSCRIPT MathGroup SUBSCRIPT MathGroup
    ;

@nonterminal MathGroup;
@rule MathGroup :=
    | BMATHGRP MathMain EMATHGRP
    | MathBot
    ;

@nonterminal MathBot;
@rule MathBot :=
    | MATCHARS
    | MCmd MathArgList
    | VAR_IN_MATH
    ;

@nonterminal MathArgList;
@rule MathArgList :=
    | @empty
    | MathArg MathArgList
    ;

@nonterminal MathArg;
@rule MathArg :=
    | BMATHGRP MathGroup EMATHGRP
    | BHORZGRP SxSep EHORZGRP
    | BVERTGRP VxBlock EVERTGRP
    | OPTIONAL BMATHGRP MathBlock EMATHGRP
    | OPTIONAL BHORZGRP SxSep EHORZGRP
    | OPTIONAL BVERTGRP VxBlock EVERTGRP
    | NArg
    ;

@nonterminal SxBlock;
@rule SxBlock :=
    | Ih
    ;

@nonterminal Ih;
@rule Ih :=
    | IhText
    | IhText IhCmd Ih
    | IhCmd Ih
    | @empty
    ;

@nonterminal NArgList;
@rule NArgList :=
    | @empty
    | NArg NArgList
    ;

@nonterminal IhCmd;
@rule IhCmd :=
    | HORZ_MACRO MacroArgs
    | HCmd NArgList SArgs
    | BMATHGRP MathBlock EMATHGRP
    | LITERAL
    | VAR_IN_HORZ ENDACTIVE
    ;

@nonterminal IhText;
@rule IhText :=
    | IhChar
    | IhChar IhText
    ;

@nonterminal IhChar;
@rule IhChar :=
    | CHAR
    | SPACE
    | BREAK
    ;

@nonterminal MacroArgs;
@rule MacroArgs :=
    | MacroNArgList ENDACTIVE
    ;

@nonterminal MacroNArgList;
@rule MacroNArgList :=
    | @empty
    | MacroNArg MacroNArgList
    ;

@nonterminal MacroNArg;
@rule MacroNArg :=
    | LPAREN NxBot RPAREN
    | EXACT_TILDE LPAREN NxBot RPAREN
    ;

@nonterminal NArg;
@rule NArg :=
    | LPAREN NxLet RPAREN
    | LPAREN RPAREN
    | NxRecordSynt
    | NxListSynt
    | OPTIONAL LPAREN NxLet RPAREN
    | OPTIONAL LPAREN RPAREN
    | OPTIONAL NxRecordSynt
    | OPTIONAL NxListSynt
    | OMISSION
    ;

@nonterminal SArgs;
@rule SArgs :=
    | ENDACTIVE
    | SArgListNonempty
    ;

@nonterminal SArgListNonempty;
@rule SArgListNonempty :=
    | SArg
    | SArg SArgListNonempty
    ;

@nonterminal SArg;
@rule SArg :=
    | BVERTGRP VxBlock EVERTGRP
    | BHORZGRP SxSep EHORZGRP
    ;

@nonterminal VCmd;
@rule VCmd :=
    | VERT_CMD
    | VERT_CMD_WITH_MOD
    ;

@nonterminal VxBlock;
@rule VxBlock :=
    | @empty
    | VxBot VxBlock
    ;

@nonterminal VxBot;
@rule VxBot :=
    | VCmd NArgList SArgs
    | VAR_IN_VERT ENDACTIVE
    | VERT_MACRO MacroArgs
    ;
